{"version":3,"file":"static/js/9387.f95ea845.chunk.js","mappings":"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","sources":["../node_modules/antd/es/_util/getScroll.js","../node_modules/antd/es/_util/scrollTo.js","../node_modules/antd/es/_util/easings.js","../node_modules/antd/es/anchor/context.js","../node_modules/antd/es/anchor/AnchorLink.js","../node_modules/antd/es/anchor/style/index.js","../node_modules/antd/es/anchor/Anchor.js","../node_modules/antd/es/anchor/index.js","../node_modules/compute-scroll-into-view/src/index.ts","../node_modules/scroll-into-view-if-needed/src/index.ts"],"sourcesContent":["export function isWindow(obj) {\n  return obj !== null && obj !== undefined && obj === obj.window;\n}\nexport default function getScroll(target, top) {\n  var _a, _b;\n  if (typeof window === 'undefined') {\n    return 0;\n  }\n  const method = top ? 'scrollTop' : 'scrollLeft';\n  let result = 0;\n  if (isWindow(target)) {\n    result = target[top ? 'pageYOffset' : 'pageXOffset'];\n  } else if (target instanceof Document) {\n    result = target.documentElement[method];\n  } else if (target instanceof HTMLElement) {\n    result = target[method];\n  } else if (target) {\n    // According to the type inference, the `target` is `never` type.\n    // Since we configured the loose mode type checking, and supports mocking the target with such shape below::\n    //    `{ documentElement: { scrollLeft: 200, scrollTop: 400 } }`,\n    //    the program may falls into this branch.\n    // Check the corresponding tests for details. Don't sure what is the real scenario this happens.\n    result = target[method];\n  }\n  if (target && !isWindow(target) && typeof result !== 'number') {\n    result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method];\n  }\n  return result;\n}","import raf from \"rc-util/es/raf\";\nimport { easeInOutCubic } from './easings';\nimport getScroll, { isWindow } from './getScroll';\nexport default function scrollTo(y) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    getContainer = () => window,\n    callback,\n    duration = 450\n  } = options;\n  const container = getContainer();\n  const scrollTop = getScroll(container, true);\n  const startTime = Date.now();\n  const frameFunc = () => {\n    const timestamp = Date.now();\n    const time = timestamp - startTime;\n    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);\n    if (isWindow(container)) {\n      container.scrollTo(window.pageXOffset, nextScrollTop);\n    } else if (container instanceof Document || container.constructor.name === 'HTMLDocument') {\n      container.documentElement.scrollTop = nextScrollTop;\n    } else {\n      container.scrollTop = nextScrollTop;\n    }\n    if (time < duration) {\n      raf(frameFunc);\n    } else if (typeof callback === 'function') {\n      callback();\n    }\n  };\n  raf(frameFunc);\n}","// eslint-disable-next-line import/prefer-default-export\nexport function easeInOutCubic(t, b, c, d) {\n  const cc = c - b;\n  t /= d / 2;\n  if (t < 1) {\n    return cc / 2 * t * t * t + b;\n  }\n  // eslint-disable-next-line no-return-assign\n  return cc / 2 * ((t -= 2) * t * t + 2) + b;\n}","import * as React from 'react';\nconst AnchorContext = /*#__PURE__*/React.createContext(undefined);\nexport default AnchorContext;","\"use client\";\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport { devUseWarning } from '../_util/warning';\nimport { ConfigContext } from '../config-provider';\nimport AnchorContext from './context';\nconst AnchorLink = props => {\n  const {\n    href,\n    title,\n    prefixCls: customizePrefixCls,\n    children,\n    className,\n    target,\n    replace\n  } = props;\n  const context = React.useContext(AnchorContext);\n  const {\n    registerLink,\n    unregisterLink,\n    scrollTo,\n    onClick,\n    activeLink,\n    direction\n  } = context || {};\n  React.useEffect(() => {\n    registerLink === null || registerLink === void 0 ? void 0 : registerLink(href);\n    return () => {\n      unregisterLink === null || unregisterLink === void 0 ? void 0 : unregisterLink(href);\n    };\n  }, [href]);\n  const handleClick = e => {\n    if (replace) {\n      e.preventDefault();\n      window.location.replace(href);\n    }\n    onClick === null || onClick === void 0 ? void 0 : onClick(e, {\n      title,\n      href\n    });\n    scrollTo === null || scrollTo === void 0 ? void 0 : scrollTo(href);\n  };\n  // =================== Warning =====================\n  if (process.env.NODE_ENV !== 'production') {\n    const warning = devUseWarning('Anchor.Link');\n    process.env.NODE_ENV !== \"production\" ? warning(!children || direction !== 'horizontal', 'usage', '`Anchor.Link children` is not supported when `Anchor` direction is horizontal') : void 0;\n  }\n  const {\n    getPrefixCls\n  } = React.useContext(ConfigContext);\n  const prefixCls = getPrefixCls('anchor', customizePrefixCls);\n  const active = activeLink === href;\n  const wrapperClassName = classNames(`${prefixCls}-link`, className, {\n    [`${prefixCls}-link-active`]: active\n  });\n  const titleClassName = classNames(`${prefixCls}-link-title`, {\n    [`${prefixCls}-link-title-active`]: active\n  });\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: wrapperClassName\n  }, /*#__PURE__*/React.createElement(\"a\", {\n    className: titleClassName,\n    href: href,\n    title: typeof title === 'string' ? title : '',\n    target: target,\n    onClick: handleClick\n  }, title), direction !== 'horizontal' ? children : null);\n};\nexport default AnchorLink;","import { unit } from '@ant-design/cssinjs';\nimport { resetComponent, textEllipsis } from '../../style';\nimport { genStyleHooks, mergeToken } from '../../theme/internal';\n// ============================== Shared ==============================\nconst genSharedAnchorStyle = token => {\n  const {\n    componentCls,\n    holderOffsetBlock,\n    motionDurationSlow,\n    lineWidthBold,\n    colorPrimary,\n    lineType,\n    colorSplit,\n    calc\n  } = token;\n  return {\n    [`${componentCls}-wrapper`]: {\n      marginBlockStart: calc(holderOffsetBlock).mul(-1).equal(),\n      paddingBlockStart: holderOffsetBlock,\n      // delete overflow: auto\n      // overflow: 'auto',\n      [componentCls]: Object.assign(Object.assign({}, resetComponent(token)), {\n        position: 'relative',\n        paddingInlineStart: lineWidthBold,\n        [`${componentCls}-link`]: {\n          paddingBlock: token.linkPaddingBlock,\n          paddingInline: `${unit(token.linkPaddingInlineStart)} 0`,\n          '&-title': Object.assign(Object.assign({}, textEllipsis), {\n            position: 'relative',\n            display: 'block',\n            marginBlockEnd: token.anchorTitleBlock,\n            color: token.colorText,\n            transition: `all ${token.motionDurationSlow}`,\n            '&:only-child': {\n              marginBlockEnd: 0\n            }\n          }),\n          [`&-active > ${componentCls}-link-title`]: {\n            color: token.colorPrimary\n          },\n          // link link\n          [`${componentCls}-link`]: {\n            paddingBlock: token.anchorPaddingBlockSecondary\n          }\n        }\n      }),\n      [`&:not(${componentCls}-wrapper-horizontal)`]: {\n        [componentCls]: {\n          '&::before': {\n            position: 'absolute',\n            insetInlineStart: 0,\n            top: 0,\n            height: '100%',\n            borderInlineStart: `${unit(lineWidthBold)} ${lineType} ${colorSplit}`,\n            content: '\" \"'\n          },\n          [`${componentCls}-ink`]: {\n            position: 'absolute',\n            insetInlineStart: 0,\n            display: 'none',\n            transform: 'translateY(-50%)',\n            transition: `top ${motionDurationSlow} ease-in-out`,\n            width: lineWidthBold,\n            backgroundColor: colorPrimary,\n            [`&${componentCls}-ink-visible`]: {\n              display: 'inline-block'\n            }\n          }\n        }\n      },\n      [`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: {\n        display: 'none'\n      }\n    }\n  };\n};\nconst genSharedAnchorHorizontalStyle = token => {\n  const {\n    componentCls,\n    motionDurationSlow,\n    lineWidthBold,\n    colorPrimary\n  } = token;\n  return {\n    [`${componentCls}-wrapper-horizontal`]: {\n      position: 'relative',\n      '&::before': {\n        position: 'absolute',\n        left: {\n          _skip_check_: true,\n          value: 0\n        },\n        right: {\n          _skip_check_: true,\n          value: 0\n        },\n        bottom: 0,\n        borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,\n        content: '\" \"'\n      },\n      [componentCls]: {\n        overflowX: 'scroll',\n        position: 'relative',\n        display: 'flex',\n        scrollbarWidth: 'none' /* Firefox */,\n        '&::-webkit-scrollbar': {\n          display: 'none' /* Safari and Chrome */\n        },\n        [`${componentCls}-link:first-of-type`]: {\n          paddingInline: 0\n        },\n        [`${componentCls}-ink`]: {\n          position: 'absolute',\n          bottom: 0,\n          transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,\n          height: lineWidthBold,\n          backgroundColor: colorPrimary\n        }\n      }\n    }\n  };\n};\nexport const prepareComponentToken = token => ({\n  linkPaddingBlock: token.paddingXXS,\n  linkPaddingInlineStart: token.padding\n});\n// ============================== Export ==============================\nexport default genStyleHooks('Anchor', token => {\n  const {\n    fontSize,\n    fontSizeLG,\n    paddingXXS,\n    calc\n  } = token;\n  const anchorToken = mergeToken(token, {\n    holderOffsetBlock: paddingXXS,\n    anchorPaddingBlockSecondary: calc(paddingXXS).div(2).equal(),\n    anchorTitleBlock: calc(fontSize).div(14).mul(3).equal(),\n    anchorBallSize: calc(fontSizeLG).div(2).equal()\n  });\n  return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];\n}, prepareComponentToken);","\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport { useEvent } from 'rc-util';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport getScroll from '../_util/getScroll';\nimport scrollTo from '../_util/scrollTo';\nimport { devUseWarning } from '../_util/warning';\nimport Affix from '../affix';\nimport { ConfigContext } from '../config-provider';\nimport useCSSVarCls from '../config-provider/hooks/useCSSVarCls';\nimport AnchorLink from './AnchorLink';\nimport AnchorContext from './context';\nimport useStyle from './style';\nfunction getDefaultContainer() {\n  return window;\n}\nfunction getOffsetTop(element, container) {\n  if (!element.getClientRects().length) {\n    return 0;\n  }\n  const rect = element.getBoundingClientRect();\n  if (rect.width || rect.height) {\n    if (container === window) {\n      container = element.ownerDocument.documentElement;\n      return rect.top - container.clientTop;\n    }\n    return rect.top - container.getBoundingClientRect().top;\n  }\n  return rect.top;\n}\nconst sharpMatcherRegex = /#([\\S ]+)$/;\nconst Anchor = props => {\n  var _a;\n  const {\n    rootClassName,\n    prefixCls: customPrefixCls,\n    className,\n    style,\n    offsetTop,\n    affix = true,\n    showInkInFixed = false,\n    children,\n    items,\n    direction: anchorDirection = 'vertical',\n    bounds,\n    targetOffset,\n    onClick,\n    onChange,\n    getContainer,\n    getCurrentAnchor,\n    replace\n  } = props;\n  // =================== Warning =====================\n  if (process.env.NODE_ENV !== 'production') {\n    const warning = devUseWarning('Anchor');\n    warning.deprecated(!children, 'Anchor children', 'items');\n    process.env.NODE_ENV !== \"production\" ? warning(!(anchorDirection === 'horizontal' && (items === null || items === void 0 ? void 0 : items.some(n => 'children' in n))), 'usage', '`Anchor items#children` is not supported when `Anchor` direction is horizontal.') : void 0;\n  }\n  const [links, setLinks] = React.useState([]);\n  const [activeLink, setActiveLink] = React.useState(null);\n  const activeLinkRef = React.useRef(activeLink);\n  const wrapperRef = React.useRef(null);\n  const spanLinkNode = React.useRef(null);\n  const animating = React.useRef(false);\n  const {\n    direction,\n    anchor,\n    getTargetContainer,\n    getPrefixCls\n  } = React.useContext(ConfigContext);\n  const prefixCls = getPrefixCls('anchor', customPrefixCls);\n  const rootCls = useCSSVarCls(prefixCls);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(prefixCls, rootCls);\n  const getCurrentContainer = (_a = getContainer !== null && getContainer !== void 0 ? getContainer : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultContainer;\n  const dependencyListItem = JSON.stringify(links);\n  const registerLink = useEvent(link => {\n    if (!links.includes(link)) {\n      setLinks(prev => [].concat(_toConsumableArray(prev), [link]));\n    }\n  });\n  const unregisterLink = useEvent(link => {\n    if (links.includes(link)) {\n      setLinks(prev => prev.filter(i => i !== link));\n    }\n  });\n  const updateInk = () => {\n    var _a;\n    const linkNode = (_a = wrapperRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(`.${prefixCls}-link-title-active`);\n    if (linkNode && spanLinkNode.current) {\n      const {\n        style: inkStyle\n      } = spanLinkNode.current;\n      const horizontalAnchor = anchorDirection === 'horizontal';\n      inkStyle.top = horizontalAnchor ? '' : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;\n      inkStyle.height = horizontalAnchor ? '' : `${linkNode.clientHeight}px`;\n      inkStyle.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : '';\n      inkStyle.width = horizontalAnchor ? `${linkNode.clientWidth}px` : '';\n      if (horizontalAnchor) {\n        scrollIntoView(linkNode, {\n          scrollMode: 'if-needed',\n          block: 'nearest'\n        });\n      }\n    }\n  };\n  const getInternalCurrentAnchor = function (_links) {\n    let _offsetTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let _bounds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    const linkSections = [];\n    const container = getCurrentContainer();\n    _links.forEach(link => {\n      const sharpLinkMatch = sharpMatcherRegex.exec(link === null || link === void 0 ? void 0 : link.toString());\n      if (!sharpLinkMatch) {\n        return;\n      }\n      const target = document.getElementById(sharpLinkMatch[1]);\n      if (target) {\n        const top = getOffsetTop(target, container);\n        if (top <= _offsetTop + _bounds) {\n          linkSections.push({\n            link,\n            top\n          });\n        }\n      }\n    });\n    if (linkSections.length) {\n      const maxSection = linkSections.reduce((prev, curr) => curr.top > prev.top ? curr : prev);\n      return maxSection.link;\n    }\n    return '';\n  };\n  const setCurrentActiveLink = useEvent(link => {\n    // FIXME: Seems a bug since this compare is not equals\n    // `activeLinkRef` is parsed value which will always trigger `onChange` event.\n    if (activeLinkRef.current === link) {\n      return;\n    }\n    // https://github.com/ant-design/ant-design/issues/30584\n    const newLink = typeof getCurrentAnchor === 'function' ? getCurrentAnchor(link) : link;\n    setActiveLink(newLink);\n    activeLinkRef.current = newLink;\n    // onChange should respect the original link (which may caused by\n    // window scroll or user click), not the new link\n    onChange === null || onChange === void 0 ? void 0 : onChange(link);\n  });\n  const handleScroll = React.useCallback(() => {\n    if (animating.current) {\n      return;\n    }\n    const currentActiveLink = getInternalCurrentAnchor(links, targetOffset !== undefined ? targetOffset : offsetTop || 0, bounds);\n    setCurrentActiveLink(currentActiveLink);\n  }, [dependencyListItem, targetOffset, offsetTop]);\n  const handleScrollTo = React.useCallback(link => {\n    setCurrentActiveLink(link);\n    const sharpLinkMatch = sharpMatcherRegex.exec(link);\n    if (!sharpLinkMatch) {\n      return;\n    }\n    const targetElement = document.getElementById(sharpLinkMatch[1]);\n    if (!targetElement) {\n      return;\n    }\n    const container = getCurrentContainer();\n    const scrollTop = getScroll(container, true);\n    const eleOffsetTop = getOffsetTop(targetElement, container);\n    let y = scrollTop + eleOffsetTop;\n    y -= targetOffset !== undefined ? targetOffset : offsetTop || 0;\n    animating.current = true;\n    scrollTo(y, {\n      getContainer: getCurrentContainer,\n      callback() {\n        animating.current = false;\n      }\n    });\n  }, [targetOffset, offsetTop]);\n  const wrapperClass = classNames(hashId, cssVarCls, rootCls, rootClassName, `${prefixCls}-wrapper`, {\n    [`${prefixCls}-wrapper-horizontal`]: anchorDirection === 'horizontal',\n    [`${prefixCls}-rtl`]: direction === 'rtl'\n  }, className, anchor === null || anchor === void 0 ? void 0 : anchor.className);\n  const anchorClass = classNames(prefixCls, {\n    [`${prefixCls}-fixed`]: !affix && !showInkInFixed\n  });\n  const inkClass = classNames(`${prefixCls}-ink`, {\n    [`${prefixCls}-ink-visible`]: activeLink\n  });\n  const wrapperStyle = Object.assign(Object.assign({\n    maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : '100vh'\n  }, anchor === null || anchor === void 0 ? void 0 : anchor.style), style);\n  const createNestedLink = options => Array.isArray(options) ? options.map(item => ( /*#__PURE__*/React.createElement(AnchorLink, Object.assign({\n    replace: replace\n  }, item, {\n    key: item.key\n  }), anchorDirection === 'vertical' && createNestedLink(item.children)))) : null;\n  const anchorContent = /*#__PURE__*/React.createElement(\"div\", {\n    ref: wrapperRef,\n    className: wrapperClass,\n    style: wrapperStyle\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: anchorClass\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    className: inkClass,\n    ref: spanLinkNode\n  }), 'items' in props ? createNestedLink(items) : children));\n  React.useEffect(() => {\n    const scrollContainer = getCurrentContainer();\n    handleScroll();\n    scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.addEventListener('scroll', handleScroll);\n    return () => {\n      scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.removeEventListener('scroll', handleScroll);\n    };\n  }, [dependencyListItem]);\n  React.useEffect(() => {\n    if (typeof getCurrentAnchor === 'function') {\n      setCurrentActiveLink(getCurrentAnchor(activeLinkRef.current || ''));\n    }\n  }, [getCurrentAnchor]);\n  React.useEffect(() => {\n    updateInk();\n  }, [anchorDirection, getCurrentAnchor, dependencyListItem, activeLink]);\n  const memoizedContextValue = React.useMemo(() => ({\n    registerLink,\n    unregisterLink,\n    scrollTo: handleScrollTo,\n    activeLink,\n    onClick,\n    direction: anchorDirection\n  }), [activeLink, onClick, handleScrollTo, anchorDirection]);\n  return wrapCSSVar( /*#__PURE__*/React.createElement(AnchorContext.Provider, {\n    value: memoizedContextValue\n  }, affix ? ( /*#__PURE__*/React.createElement(Affix, {\n    offsetTop: offsetTop,\n    target: getCurrentContainer\n  }, anchorContent)) : anchorContent));\n};\nif (process.env.NODE_ENV !== 'production') {\n  Anchor.displayName = 'Anchor';\n}\nexport default Anchor;","\"use client\";\n\nimport InternalAnchor from './Anchor';\nimport AnchorLink from './AnchorLink';\nconst Anchor = InternalAnchor;\nAnchor.Link = AnchorLink;\nexport default Anchor;","// Compute what scrolling needs to be done on required scrolling boxes for target to be in view\n\n// The type names here are named after the spec to make it easier to find more information around what they mean:\n// To reduce churn and reduce things that need be maintained things from the official TS DOM library is used here\n// https://drafts.csswg.org/cssom-view/\n\n// For a definition on what is \"block flow direction\" exactly, check this: https://drafts.csswg.org/css-writing-modes-4/#block-flow-direction\n\n/**\n * This new option is tracked in this PR, which is the most likely candidate at the time: https://github.com/w3c/csswg-drafts/pull/1805\n * @public\n */\nexport type ScrollMode = 'always' | 'if-needed'\n\n/** @public */\nexport interface Options {\n  /**\n   * Control the logical scroll position on the y-axis. The spec states that the `block` direction is related to the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode), but this is not implemented yet in this library.\n   * This means that `block: 'start'` aligns to the top edge and `block: 'end'` to the bottom.\n   * @defaultValue 'center'\n   */\n  block?: ScrollLogicalPosition\n  /**\n   * Like `block` this is affected by the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode). In left-to-right pages `inline: 'start'` will align to the left edge. In right-to-left it should be flipped. This will be supported in a future release.\n   * @defaultValue 'nearest'\n   */\n  inline?: ScrollLogicalPosition\n  /**\n   * This is a proposed addition to the spec that you can track here: https://github.com/w3c/csswg-drafts/pull/5677\n   *\n   * This library will be updated to reflect any changes to the spec and will provide a migration path.\n   * To be backwards compatible with `Element.scrollIntoViewIfNeeded` if something is not 100% visible it will count as \"needs scrolling\". If you need a different visibility ratio your best option would be to implement an [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n   * @defaultValue 'always'\n   */\n  scrollMode?: ScrollMode\n  /**\n   * By default there is no boundary. All the parent elements of your target is checked until it reaches the viewport ([`document.scrollingElement`](https://developer.mozilla.org/en-US/docs/Web/API/document/scrollingElement)) when calculating layout and what to scroll.\n   * By passing a boundary you can short-circuit this loop depending on your needs:\n   * \n   * - Prevent the browser window from scrolling.\n   * - Scroll elements into view in a list, without scrolling container elements.\n   * \n   * You can also pass a function to do more dynamic checks to override the scroll scoping:\n   * \n   * ```js\n   * let actions = compute(target, {\n   *   boundary: (parent) => {\n   *     // By default `overflow: hidden` elements are allowed, only `overflow: visible | clip` is skipped as\n   *     // this is required by the CSSOM spec\n   *     if (getComputedStyle(parent)['overflow'] === 'hidden') {\n   *       return false\n   *     }\n\n   *     return true\n   *   },\n   * })\n   * ```\n   * @defaultValue null\n   */\n  boundary?: Element | ((parent: Element) => boolean) | null\n  /**\n   * New option that skips auto-scrolling all nodes with overflow: hidden set\n   * See FF implementation: https://hg.mozilla.org/integration/fx-team/rev/c48c3ec05012#l7.18\n   * @defaultValue false\n   * @public\n   */\n  skipOverflowHiddenElements?: boolean\n}\n\n/** @public */\nexport interface ScrollAction {\n  el: Element\n  top: number\n  left: number\n}\n\n// @TODO better shadowdom test, 11 = document fragment\nconst isElement = (el: any): el is Element =>\n  typeof el === 'object' && el != null && el.nodeType === 1\n\nconst canOverflow = (\n  overflow: string | null,\n  skipOverflowHiddenElements?: boolean\n) => {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip'\n}\n\nconst getFrameElement = (el: Element) => {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null\n  }\n\n  try {\n    return el.ownerDocument.defaultView.frameElement\n  } catch (e) {\n    return null\n  }\n}\n\nconst isHiddenByFrame = (el: Element): boolean => {\n  const frame = getFrameElement(el)\n  if (!frame) {\n    return false\n  }\n\n  return (\n    frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth\n  )\n}\n\nconst isScrollable = (el: Element, skipOverflowHiddenElements?: boolean) => {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    const style = getComputedStyle(el, null)\n    return (\n      canOverflow(style.overflowY, skipOverflowHiddenElements) ||\n      canOverflow(style.overflowX, skipOverflowHiddenElements) ||\n      isHiddenByFrame(el)\n    )\n  }\n\n  return false\n}\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst alignNearest = (\n  scrollingEdgeStart: number,\n  scrollingEdgeEnd: number,\n  scrollingSize: number,\n  scrollingBorderStart: number,\n  scrollingBorderEnd: number,\n  elementEdgeStart: number,\n  elementEdgeEnd: number,\n  elementSize: number\n) => {\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓\n   *          │  │\n   *        ┃ │  │ ┃        do nothing\n   *          │  │\n   *        ┗━│━━│━┛\n   *          └──┘\n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *    ┏ ━ ━ ━ ━ ┓\n   *   ┌───────────┐\n   *   │┃         ┃│        do nothing\n   *   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛\n   */\n  if (\n    (elementEdgeStart < scrollingEdgeStart &&\n      elementEdgeEnd > scrollingEdgeEnd) ||\n    (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n  ) {\n    return 0\n  }\n\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓         ┏━┌━━┐━┓\n   *          └──┘             │  │\n   *  from  ┃      ┃     to  ┃ └──┘ ┃\n   *\n   *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n   *                           │  │\n   *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n   *          │  │             │  │\n   *        ┗━│━━│━┛         ┗━│━━│━┛\n   *          │  │             └──┘\n   *          │  │\n   *          └──┘\n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───┐                 ┌───┐\n   *  │ ┃ │       ┃         ┃   │     ┃\n   *  └───┘                 └───┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *        ┌───────────┐   ┌───────────┐\n   *    ┃   │     ┃     │   ┃         ┃ │\n   *        └───────────┘   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   */\n  if (\n    (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n    (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n  ) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart\n  }\n\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n   *\n   *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n   *          ┌──┐             │  │\n   *        ┗━│━━│━┛         ┗━└━━┘━┛\n   *          └──┘\n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          ┌──┐\n   *          │  │\n   *          │  │             ┌──┐\n   *        ┏━│━━│━┓         ┏━│━━│━┓\n   *          │  │             │  │\n   *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n   *                           │  │\n   *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───────────┐           ┌───────────┐\n   *  │     ┃     │   ┃       │ ┃         ┃\n   *  └───────────┘           └───────────┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *                ┌───┐             ┌───┐\n   *        ┃       │ ┃ │       ┃     │   ┃\n   *                └───┘             └───┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   */\n  if (\n    (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n    (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n  ) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd\n  }\n\n  return 0\n}\n\nconst getParentElement = (element: Node): Element | null => {\n  const parent = element.parentElement\n  if (parent == null) {\n    return (element.getRootNode() as ShadowRoot).host || null\n  }\n  return parent\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n/** @public */\nexport const compute = (target: Element, options: Options): ScrollAction[] => {\n  if (typeof document === 'undefined') {\n    // If there's no DOM we assume it's not in a browser environment\n    return []\n  }\n\n  const { scrollMode, block, inline, boundary, skipOverflowHiddenElements } =\n    options\n  // Allow using a callback to check the boundary\n  // The default behavior is to check if the current target matches the boundary element or not\n  // If undefined it'll check that target is never undefined (can happen as we recurse up the tree)\n  const checkBoundary =\n    typeof boundary === 'function' ? boundary : (node: any) => node !== boundary\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target')\n  }\n\n  // Used to handle the top most element that can be scrolled\n  const scrollingElement = document.scrollingElement || document.documentElement\n\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const frames: Element[] = []\n  let cursor: Element | null = target\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    // Move cursor to parent\n    cursor = getParentElement(cursor)\n\n    // Stop when we reach the viewport\n    if (cursor === scrollingElement) {\n      frames.push(cursor)\n      break\n    }\n\n    // Skip document.body if it's not the scrollingElement and documentElement isn't independently scrollable\n    if (\n      cursor != null &&\n      cursor === document.body &&\n      isScrollable(cursor) &&\n      !isScrollable(document.documentElement)\n    ) {\n      continue\n    }\n\n    // Now we check if the element is scrollable, this code only runs if the loop haven't already hit the viewport or a custom boundary\n    if (cursor != null && isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor)\n    }\n  }\n\n  // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n  // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n  // and viewport dimensions on window.innerWidth/Height\n  // https://www.quirksmode.org/mobile/viewports2.html\n  // https://bokand.github.io/viewport/index.html\n  const viewportWidth = window.visualViewport?.width ?? innerWidth\n  const viewportHeight = window.visualViewport?.height ?? innerHeight\n  const { scrollX, scrollY } = window\n\n  const {\n    height: targetHeight,\n    width: targetWidth,\n    top: targetTop,\n    right: targetRight,\n    bottom: targetBottom,\n    left: targetLeft,\n  } = target.getBoundingClientRect()\n  const {\n    top: marginTop,\n    right: marginRight,\n    bottom: marginBottom,\n    left: marginLeft,\n  } = getScrollMargins(target)\n\n  // These values mutate as we loop through and generate scroll coordinates\n  let targetBlock: number =\n    block === 'start' || block === 'nearest'\n      ? targetTop - marginTop\n      : block === 'end'\n      ? targetBottom + marginBottom\n      : targetTop + targetHeight / 2 - marginTop + marginBottom // block === 'center\n  let targetInline: number =\n    inline === 'center'\n      ? targetLeft + targetWidth / 2 - marginLeft + marginRight\n      : inline === 'end'\n      ? targetRight + marginRight\n      : targetLeft - marginLeft // inline === 'start || inline === 'nearest\n\n  // Collect new scroll positions\n  const computations: ScrollAction[] = []\n  // In chrome there's no longer a difference between caching the `frames.length` to a var or not, so we don't in this case (size > speed anyways)\n  for (let index = 0; index < frames.length; index++) {\n    const frame = frames[index]\n\n    // @TODO add a shouldScroll hook here that allows userland code to take control\n\n    const { height, width, top, right, bottom, left } =\n      frame.getBoundingClientRect()\n\n    // If the element is already visible we can end it here\n    // @TODO targetBlock and targetInline should be taken into account to be compliant with https://github.com/w3c/csswg-drafts/pull/1805/files#diff-3c17f0e43c20f8ecf89419d49e7ef5e0R1333\n    if (\n      scrollMode === 'if-needed' &&\n      targetTop >= 0 &&\n      targetLeft >= 0 &&\n      targetBottom <= viewportHeight &&\n      targetRight <= viewportWidth &&\n      targetTop >= top &&\n      targetBottom <= bottom &&\n      targetLeft >= left &&\n      targetRight <= right\n    ) {\n      // Break the loop and return the computations for things that are not fully visible\n      return computations\n    }\n\n    const frameStyle = getComputedStyle(frame)\n    const borderLeft = parseInt(frameStyle.borderLeftWidth as string, 10)\n    const borderTop = parseInt(frameStyle.borderTopWidth as string, 10)\n    const borderRight = parseInt(frameStyle.borderRightWidth as string, 10)\n    const borderBottom = parseInt(frameStyle.borderBottomWidth as string, 10)\n\n    let blockScroll: number = 0\n    let inlineScroll: number = 0\n\n    // The property existance checks for offfset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n    // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n    const scrollbarWidth =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth -\n          (frame as HTMLElement).clientWidth -\n          borderLeft -\n          borderRight\n        : 0\n    const scrollbarHeight =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight -\n          (frame as HTMLElement).clientHeight -\n          borderTop -\n          borderBottom\n        : 0\n\n    const scaleX =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth === 0\n          ? 0\n          : width / (frame as HTMLElement).offsetWidth\n        : 0\n    const scaleY =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight === 0\n          ? 0\n          : height / (frame as HTMLElement).offsetHeight\n        : 0\n\n    if (scrollingElement === frame) {\n      // Handle viewport logic (document.documentElement or document.body)\n\n      if (block === 'start') {\n        blockScroll = targetBlock\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          scrollY,\n          scrollY + viewportHeight,\n          viewportHeight,\n          borderTop,\n          borderBottom,\n          scrollY + targetBlock,\n          scrollY + targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - viewportHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          scrollX,\n          scrollX + viewportWidth,\n          viewportWidth,\n          borderLeft,\n          borderRight,\n          scrollX + targetInline,\n          scrollX + targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      // Apply scroll position offsets and ensure they are within bounds\n      // @TODO add more test cases to cover this 100%\n      blockScroll = Math.max(0, blockScroll + scrollY)\n      inlineScroll = Math.max(0, inlineScroll + scrollX)\n    } else {\n      // Handle each scrolling frame that might exist between the target and the viewport\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          top,\n          bottom,\n          height,\n          borderTop,\n          borderBottom + scrollbarHeight,\n          targetBlock,\n          targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          left,\n          right,\n          width,\n          borderLeft,\n          borderRight + scrollbarWidth,\n          targetInline,\n          targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      const { scrollLeft, scrollTop } = frame\n      // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n      blockScroll =\n        scaleY === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollTop + blockScroll / scaleY,\n                frame.scrollHeight - height / scaleY + scrollbarHeight\n              )\n            )\n      inlineScroll =\n        scaleX === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollLeft + inlineScroll / scaleX,\n                frame.scrollWidth - width / scaleX + scrollbarWidth\n              )\n            )\n\n      // Cache the offset so that parent frames can scroll this into view correctly\n      targetBlock += scrollTop - blockScroll\n      targetInline += scrollLeft - inlineScroll\n    }\n\n    computations.push({ el: frame, top: blockScroll, left: inlineScroll })\n  }\n\n  return computations\n}\n","import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nconst isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nconst isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nconst getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  let currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  const margins = getScrollMargins(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  const behavior = typeof options === 'boolean' ? undefined : options?.behavior\n\n  for (const { el, top, left } of compute(target, getOptions(options))) {\n    const adjustedTop = top - margins.top + margins.bottom\n    const adjustedLeft = left - margins.left + margins.right\n    el.scroll({ top: adjustedTop, left: adjustedLeft, behavior })\n  }\n}\n\nexport default scrollIntoView\n"],"names":["isWindow","obj","undefined","window","getScroll","target","top","_a","_b","method","result","Document","documentElement","HTMLElement","ownerDocument","scrollTo","y","options","arguments","length","getContainer","callback","duration","container","scrollTop","startTime","Date","now","frameFunc","time","nextScrollTop","t","b","c","d","cc","easeInOutCubic","pageXOffset","constructor","name","raf","React","props","href","title","prefixCls","customizePrefixCls","children","className","replace","context","AnchorContext","registerLink","unregisterLink","onClick","activeLink","direction","getPrefixCls","ConfigContext","active","wrapperClassName","classNames","concat","titleClassName","e","preventDefault","location","genSharedAnchorStyle","token","componentCls","holderOffsetBlock","motionDurationSlow","lineWidthBold","colorPrimary","lineType","colorSplit","calc","marginBlockStart","mul","equal","paddingBlockStart","Object","assign","resetComponent","position","paddingInlineStart","paddingBlock","linkPaddingBlock","paddingInline","unit","linkPaddingInlineStart","textEllipsis","display","marginBlockEnd","anchorTitleBlock","color","colorText","transition","anchorPaddingBlockSecondary","insetInlineStart","height","borderInlineStart","content","transform","width","backgroundColor","genSharedAnchorHorizontalStyle","left","_skip_check_","value","right","bottom","borderBottom","lineWidth","overflowX","scrollbarWidth","genStyleHooks","fontSize","fontSizeLG","paddingXXS","anchorToken","mergeToken","div","anchorBallSize","padding","getDefaultContainer","getOffsetTop","element","getClientRects","rect","getBoundingClientRect","clientTop","sharpMatcherRegex","rootClassName","customPrefixCls","style","offsetTop","affix","showInkInFixed","items","anchorDirection","bounds","targetOffset","onChange","getCurrentAnchor","links","setLinks","setActiveLink","activeLinkRef","wrapperRef","spanLinkNode","animating","anchor","getTargetContainer","rootCls","useCSSVarCls","wrapCSSVar","hashId","cssVarCls","useStyle","getCurrentContainer","dependencyListItem","JSON","stringify","useEvent","link","includes","prev","_toConsumableArray","filter","i","setCurrentActiveLink","current","newLink","handleScroll","currentActiveLink","_links","_offsetTop","_bounds","linkSections","forEach","sharpLinkMatch","exec","toString","document","getElementById","push","reduce","curr","getInternalCurrentAnchor","handleScrollTo","targetElement","wrapperClass","anchorClass","inkClass","wrapperStyle","maxHeight","createNestedLink","Array","isArray","map","item","AnchorLink","key","anchorContent","ref","scrollContainer","addEventListener","removeEventListener","updateInk","linkNode","querySelector","inkStyle","horizontalAnchor","clientHeight","offsetLeft","clientWidth","scrollIntoView","scrollMode","block","memoizedContextValue","Provider","Affix","Anchor","InternalAnchor","Link","nodeType","n","scrollHeight","scrollWidth","o","getComputedStyle","overflowY","defaultView","frameElement","l","r","s","parentElement","getRootNode","host","h","f","inline","u","boundary","a","skipOverflowHiddenElements","g","p","TypeError","m","scrollingElement","w","W","body","visualViewport","innerWidth","H","innerHeight","scrollX","scrollY","M","v","E","x","C","I","R","T","B","F","V","parseFloat","scrollMarginTop","scrollMarginRight","scrollMarginBottom","scrollMarginLeft","k","D","L","parseInt","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","offsetWidth","offsetHeight","S","X","Math","max","scrollLeft","min","el","keys","isConnected","parentNode","ShadowRoot","behavior","scroll"],"sourceRoot":""}